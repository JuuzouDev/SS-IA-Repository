{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\n// Utilities\nimport { computed, effectScope, nextTick, onScopeDispose, ref, watch, watchEffect } from 'vue';\nimport { clamp, consoleError, convertToUnit, destructComputed, flipAlign, flipCorner, flipSide, getAxis, getScrollParents, IN_BROWSER, isFixedPosition, nullifyTransforms, parseAnchor, propsFactory } from \"../../util/index.mjs\";\nimport { Box, getOverflow } from \"../../util/box.mjs\";\nimport { anchorToPoint, getOffset } from \"./util/point.mjs\"; // Types\nconst locationStrategies = {\n  static: staticLocationStrategy,\n  // specific viewport position, usually centered\n  connected: connectedLocationStrategy // connected to a certain element\n};\nexport const makeLocationStrategyProps = propsFactory({\n  locationStrategy: {\n    type: [String, Function],\n    default: 'static',\n    validator: val => typeof val === 'function' || val in locationStrategies\n  },\n  location: {\n    type: String,\n    default: 'bottom'\n  },\n  origin: {\n    type: String,\n    default: 'auto'\n  },\n  offset: [Number, String, Array]\n}, 'VOverlay/locationStrategies');\nexport function useLocationStrategies(props, data) {\n  const contentStyles = ref({});\n  const updateLocation = ref();\n  let scope;\n  watchEffect(async () => {\n    var _scope;\n    (_scope = scope) == null ? void 0 : _scope.stop();\n    updateLocation.value = undefined;\n    if (!(IN_BROWSER && data.isActive.value && props.locationStrategy)) return;\n    scope = effectScope();\n    await nextTick();\n    scope.run(() => {\n      if (typeof props.locationStrategy === 'function') {\n        var _props$locationStrate;\n        updateLocation.value = (_props$locationStrate = props.locationStrategy(data, props, contentStyles)) == null ? void 0 : _props$locationStrate.updateLocation;\n      } else {\n        var _locationStrategies$p;\n        updateLocation.value = (_locationStrategies$p = locationStrategies[props.locationStrategy](data, props, contentStyles)) == null ? void 0 : _locationStrategies$p.updateLocation;\n      }\n    });\n  });\n  IN_BROWSER && window.addEventListener('resize', onResize, {\n    passive: true\n  });\n  onScopeDispose(() => {\n    var _scope2;\n    IN_BROWSER && window.removeEventListener('resize', onResize);\n    updateLocation.value = undefined;\n    (_scope2 = scope) == null ? void 0 : _scope2.stop();\n  });\n  function onResize(e) {\n    var _updateLocation$value;\n    (_updateLocation$value = updateLocation.value) == null ? void 0 : _updateLocation$value.call(updateLocation, e);\n  }\n  return {\n    contentStyles,\n    updateLocation\n  };\n}\nfunction staticLocationStrategy() {\n  // TODO\n}\n\n/** Get size of element ignoring max-width/max-height */\nfunction getIntrinsicSize(el) {\n  // const scrollables = new Map<Element, [number, number]>()\n  // el.querySelectorAll('*').forEach(el => {\n  //   const x = el.scrollLeft\n  //   const y = el.scrollTop\n  //   if (x || y) {\n  //     scrollables.set(el, [x, y])\n  //   }\n  // })\n\n  // const initialMaxWidth = el.style.maxWidth\n  // const initialMaxHeight = el.style.maxHeight\n  // el.style.removeProperty('max-width')\n  // el.style.removeProperty('max-height')\n\n  /* eslint-disable-next-line sonarjs/prefer-immediate-return */\n  const contentBox = nullifyTransforms(el);\n  contentBox.x -= parseFloat(el.style.left || 0);\n  contentBox.y -= parseFloat(el.style.top || 0);\n\n  // el.style.maxWidth = initialMaxWidth\n  // el.style.maxHeight = initialMaxHeight\n  // scrollables.forEach((position, el) => {\n  //   el.scrollTo(...position)\n  // })\n\n  return contentBox;\n}\nfunction connectedLocationStrategy(data, props, contentStyles) {\n  const activatorFixed = isFixedPosition(data.activatorEl.value);\n  if (activatorFixed) {\n    Object.assign(contentStyles.value, {\n      position: 'fixed'\n    });\n  }\n  const {\n    preferredAnchor,\n    preferredOrigin\n  } = destructComputed(() => {\n    const parsedAnchor = parseAnchor(props.location, data.isRtl.value);\n    const parsedOrigin = props.origin === 'overlap' ? parsedAnchor : props.origin === 'auto' ? flipSide(parsedAnchor) : parseAnchor(props.origin, data.isRtl.value);\n\n    // Some combinations of props may produce an invalid origin\n    if (parsedAnchor.side === parsedOrigin.side && parsedAnchor.align === flipAlign(parsedOrigin).align) {\n      return {\n        preferredAnchor: flipCorner(parsedAnchor),\n        preferredOrigin: flipCorner(parsedOrigin)\n      };\n    } else {\n      return {\n        preferredAnchor: parsedAnchor,\n        preferredOrigin: parsedOrigin\n      };\n    }\n  });\n  const [minWidth, minHeight, maxWidth, maxHeight] = ['minWidth', 'minHeight', 'maxWidth', 'maxHeight'].map(key => {\n    return computed(() => {\n      const val = parseFloat(props[key]);\n      return isNaN(val) ? Infinity : val;\n    });\n  });\n  const offset = computed(() => {\n    if (Array.isArray(props.offset)) {\n      return props.offset;\n    }\n    if (typeof props.offset === 'string') {\n      const offset = props.offset.split(' ').map(parseFloat);\n      if (offset.length < 2) offset.push(0);\n      return offset;\n    }\n    return typeof props.offset === 'number' ? [props.offset, 0] : [0, 0];\n  });\n  let observe = false;\n  if (IN_BROWSER) {\n    const observer = new ResizeObserver(() => {\n      if (observe) updateLocation();\n    });\n    watch([data.activatorEl, data.contentEl], (_ref, _ref2) => {\n      let [newActivatorEl, newContentEl] = _ref;\n      let [oldActivatorEl, oldContentEl] = _ref2;\n      if (oldActivatorEl) observer.unobserve(oldActivatorEl);\n      if (newActivatorEl) observer.observe(newActivatorEl);\n      if (oldContentEl) observer.unobserve(oldContentEl);\n      if (newContentEl) observer.observe(newContentEl);\n    }, {\n      immediate: true\n    });\n    onScopeDispose(() => {\n      observer.disconnect();\n    });\n  }\n\n  // eslint-disable-next-line max-statements\n  function updateLocation() {\n    observe = false;\n    requestAnimationFrame(() => {\n      requestAnimationFrame(() => observe = true);\n    });\n    if (!data.activatorEl.value || !data.contentEl.value) return;\n    const targetBox = data.activatorEl.value.getBoundingClientRect();\n    const contentBox = getIntrinsicSize(data.contentEl.value);\n    const scrollParents = getScrollParents(data.contentEl.value);\n    const viewportMargin = 12;\n    if (!scrollParents.length) {\n      scrollParents.push(document.documentElement);\n      if (!(data.contentEl.value.style.top && data.contentEl.value.style.left)) {\n        contentBox.x += parseFloat(document.documentElement.style.getPropertyValue('--v-body-scroll-x') || 0);\n        contentBox.y += parseFloat(document.documentElement.style.getPropertyValue('--v-body-scroll-y') || 0);\n      }\n    }\n    const viewport = scrollParents.reduce((box, el) => {\n      const rect = el.getBoundingClientRect();\n      const scrollBox = new Box({\n        x: el === document.documentElement ? 0 : rect.x,\n        y: el === document.documentElement ? 0 : rect.y,\n        width: el.clientWidth,\n        height: el.clientHeight\n      });\n      if (box) {\n        return new Box({\n          x: Math.max(box.left, scrollBox.left),\n          y: Math.max(box.top, scrollBox.top),\n          width: Math.min(box.right, scrollBox.right) - Math.max(box.left, scrollBox.left),\n          height: Math.min(box.bottom, scrollBox.bottom) - Math.max(box.top, scrollBox.top)\n        });\n      }\n      return scrollBox;\n    }, undefined);\n    viewport.x += viewportMargin;\n    viewport.y += viewportMargin;\n    viewport.width -= viewportMargin * 2;\n    viewport.height -= viewportMargin * 2;\n    let placement = {\n      anchor: preferredAnchor.value,\n      origin: preferredOrigin.value\n    };\n    function checkOverflow(_placement) {\n      const box = new Box(contentBox);\n      const targetPoint = anchorToPoint(_placement.anchor, targetBox);\n      const contentPoint = anchorToPoint(_placement.origin, box);\n      let {\n        x,\n        y\n      } = getOffset(targetPoint, contentPoint);\n      switch (_placement.anchor.side) {\n        case 'top':\n          y -= offset.value[0];\n          break;\n        case 'bottom':\n          y += offset.value[0];\n          break;\n        case 'left':\n          x -= offset.value[0];\n          break;\n        case 'right':\n          x += offset.value[0];\n          break;\n      }\n      switch (_placement.anchor.align) {\n        case 'top':\n          y -= offset.value[1];\n          break;\n        case 'bottom':\n          y += offset.value[1];\n          break;\n        case 'left':\n          x -= offset.value[1];\n          break;\n        case 'right':\n          x += offset.value[1];\n          break;\n      }\n      box.x += x;\n      box.y += y;\n      box.width = Math.min(box.width, maxWidth.value);\n      box.height = Math.min(box.height, maxHeight.value);\n      const overflows = getOverflow(box, viewport);\n      return {\n        overflows,\n        x,\n        y\n      };\n    }\n    let x = 0;\n    let y = 0;\n    const available = {\n      x: 0,\n      y: 0\n    };\n    const flipped = {\n      x: false,\n      y: false\n    };\n    let resets = -1;\n    while (true) {\n      if (resets++ > 10) {\n        consoleError('Infinite loop detected in connectedLocationStrategy');\n        break;\n      }\n      const {\n        x: _x,\n        y: _y,\n        overflows\n      } = checkOverflow(placement);\n      x += _x;\n      y += _y;\n      contentBox.x += _x;\n      contentBox.y += _y;\n\n      // flip\n      {\n        const axis = getAxis(placement.anchor);\n        const hasOverflowX = overflows.x.before || overflows.x.after;\n        const hasOverflowY = overflows.y.before || overflows.y.after;\n        let reset = false;\n        ['x', 'y'].forEach(key => {\n          if (key === 'x' && hasOverflowX && !flipped.x || key === 'y' && hasOverflowY && !flipped.y) {\n            const newPlacement = {\n              anchor: {\n                ...placement.anchor\n              },\n              origin: {\n                ...placement.origin\n              }\n            };\n            const flip = key === 'x' ? axis === 'y' ? flipAlign : flipSide : axis === 'y' ? flipSide : flipAlign;\n            newPlacement.anchor = flip(newPlacement.anchor);\n            newPlacement.origin = flip(newPlacement.origin);\n            const {\n              overflows: newOverflows\n            } = checkOverflow(newPlacement);\n            if (newOverflows[key].before <= overflows[key].before && newOverflows[key].after <= overflows[key].after || newOverflows[key].before + newOverflows[key].after < (overflows[key].before + overflows[key].after) / 2) {\n              placement = newPlacement;\n              reset = flipped[key] = true;\n            }\n          }\n        });\n        if (reset) continue;\n      }\n\n      // shift\n      if (overflows.x.before) {\n        x += overflows.x.before;\n        contentBox.x += overflows.x.before;\n      }\n      if (overflows.x.after) {\n        x -= overflows.x.after;\n        contentBox.x -= overflows.x.after;\n      }\n      if (overflows.y.before) {\n        y += overflows.y.before;\n        contentBox.y += overflows.y.before;\n      }\n      if (overflows.y.after) {\n        y -= overflows.y.after;\n        contentBox.y -= overflows.y.after;\n      }\n\n      // size\n      {\n        const overflows = getOverflow(contentBox, viewport);\n        available.x = viewport.width - overflows.x.before - overflows.x.after;\n        available.y = viewport.height - overflows.y.before - overflows.y.after;\n        x += overflows.x.before;\n        contentBox.x += overflows.x.before;\n        y += overflows.y.before;\n        contentBox.y += overflows.y.before;\n      }\n      break;\n    }\n    const axis = getAxis(placement.anchor);\n    Object.assign(contentStyles.value, {\n      '--v-overlay-anchor-origin': `${placement.anchor.side} ${placement.anchor.align}`,\n      transformOrigin: `${placement.origin.side} ${placement.origin.align}`,\n      // transform: `translate(${pixelRound(x)}px, ${pixelRound(y)}px)`,\n      top: convertToUnit(pixelRound(y)),\n      left: convertToUnit(pixelRound(x)),\n      minWidth: convertToUnit(axis === 'y' ? Math.min(minWidth.value, targetBox.width) : minWidth.value),\n      maxWidth: convertToUnit(pixelCeil(clamp(available.x, minWidth.value === Infinity ? 0 : minWidth.value, maxWidth.value))),\n      maxHeight: convertToUnit(pixelCeil(clamp(available.y, minHeight.value === Infinity ? 0 : minHeight.value, maxHeight.value)))\n    });\n  }\n  watch(() => [preferredAnchor.value, preferredOrigin.value, props.offset, props.minWidth, props.minHeight, props.maxWidth, props.maxHeight], () => updateLocation(), {\n    immediate: !activatorFixed\n  });\n  if (activatorFixed) nextTick(() => updateLocation());\n  requestAnimationFrame(() => {\n    if (contentStyles.value.maxHeight) updateLocation();\n  });\n  return {\n    updateLocation\n  };\n}\nfunction pixelRound(val) {\n  return Math.round(val * devicePixelRatio) / devicePixelRatio;\n}\nfunction pixelCeil(val) {\n  return Math.ceil(val * devicePixelRatio) / devicePixelRatio;\n}","map":{"version":3,"names":["computed","effectScope","nextTick","onScopeDispose","ref","watch","watchEffect","clamp","consoleError","convertToUnit","destructComputed","flipAlign","flipCorner","flipSide","getAxis","getScrollParents","IN_BROWSER","isFixedPosition","nullifyTransforms","parseAnchor","propsFactory","Box","getOverflow","anchorToPoint","getOffset","locationStrategies","static","staticLocationStrategy","connected","connectedLocationStrategy","makeLocationStrategyProps","locationStrategy","type","String","Function","default","validator","val","location","origin","offset","Number","Array","useLocationStrategies","props","data","contentStyles","updateLocation","scope","_scope","stop","value","undefined","isActive","run","_props$locationStrate","_locationStrategies$p","window","addEventListener","onResize","passive","_scope2","removeEventListener","e","_updateLocation$value","call","getIntrinsicSize","el","contentBox","x","parseFloat","style","left","y","top","activatorFixed","activatorEl","Object","assign","position","preferredAnchor","preferredOrigin","parsedAnchor","isRtl","parsedOrigin","side","align","minWidth","minHeight","maxWidth","maxHeight","map","key","isNaN","Infinity","isArray","split","length","push","observe","observer","ResizeObserver","contentEl","_ref","_ref2","newActivatorEl","newContentEl","oldActivatorEl","oldContentEl","unobserve","immediate","disconnect","requestAnimationFrame","targetBox","getBoundingClientRect","scrollParents","viewportMargin","document","documentElement","getPropertyValue","viewport","reduce","box","rect","scrollBox","width","clientWidth","height","clientHeight","Math","max","min","right","bottom","placement","anchor","checkOverflow","_placement","targetPoint","contentPoint","overflows","available","flipped","resets","_x","_y","axis","hasOverflowX","before","after","hasOverflowY","reset","forEach","newPlacement","flip","newOverflows","transformOrigin","pixelRound","pixelCeil","round","devicePixelRatio","ceil"],"sources":["../../../src/components/VOverlay/locationStrategies.ts"],"sourcesContent":["// Utilities\nimport { computed, effectScope, nextTick, onScopeDispose, ref, watch, watchEffect } from 'vue'\nimport {\n  clamp,\n  consoleError,\n  convertToUnit,\n  destructComputed,\n  flipAlign,\n  flipCorner,\n  flipSide,\n  getAxis,\n  getScrollParents,\n  IN_BROWSER,\n  isFixedPosition,\n  nullifyTransforms,\n  parseAnchor,\n  propsFactory,\n} from '@/util'\nimport { Box, getOverflow } from '@/util/box'\nimport { anchorToPoint, getOffset } from './util/point'\n\n// Types\nimport type { EffectScope, PropType, Ref } from 'vue'\nimport type { Anchor } from '@/util'\n\nexport interface LocationStrategyData {\n  contentEl: Ref<HTMLElement | undefined>\n  activatorEl: Ref<HTMLElement | undefined>\n  isActive: Ref<boolean>\n  isRtl: Ref<boolean>\n}\n\ntype LocationStrategyFn = (\n  data: LocationStrategyData,\n  props: StrategyProps,\n  contentStyles: Ref<Record<string, string>>\n) => undefined | { updateLocation: (e: Event) => void }\n\nconst locationStrategies = {\n  static: staticLocationStrategy, // specific viewport position, usually centered\n  connected: connectedLocationStrategy, // connected to a certain element\n}\n\nexport interface StrategyProps {\n  locationStrategy: keyof typeof locationStrategies | LocationStrategyFn\n  location: Anchor\n  origin: Anchor | 'auto' | 'overlap'\n  offset?: number | string | number[]\n  maxHeight?: number | string\n  maxWidth?: number | string\n  minHeight?: number | string\n  minWidth?: number | string\n}\n\nexport const makeLocationStrategyProps = propsFactory({\n  locationStrategy: {\n    type: [String, Function] as PropType<StrategyProps['locationStrategy']>,\n    default: 'static',\n    validator: (val: any) => typeof val === 'function' || val in locationStrategies,\n  },\n  location: {\n    type: String as PropType<StrategyProps['location']>,\n    default: 'bottom',\n  },\n  origin: {\n    type: String as PropType<StrategyProps['origin']>,\n    default: 'auto',\n  },\n  offset: [Number, String, Array] as PropType<StrategyProps['offset']>,\n}, 'VOverlay/locationStrategies')\n\nexport function useLocationStrategies (\n  props: StrategyProps,\n  data: LocationStrategyData\n) {\n  const contentStyles = ref({})\n  const updateLocation = ref<(e: Event) => void>()\n\n  let scope: EffectScope | undefined\n  watchEffect(async () => {\n    scope?.stop()\n    updateLocation.value = undefined\n\n    if (!(IN_BROWSER && data.isActive.value && props.locationStrategy)) return\n\n    scope = effectScope()\n    await nextTick()\n    scope.run(() => {\n      if (typeof props.locationStrategy === 'function') {\n        updateLocation.value = props.locationStrategy(data, props, contentStyles)?.updateLocation\n      } else {\n        updateLocation.value = locationStrategies[props.locationStrategy](data, props, contentStyles)?.updateLocation\n      }\n    })\n  })\n\n  IN_BROWSER && window.addEventListener('resize', onResize, { passive: true })\n\n  onScopeDispose(() => {\n    IN_BROWSER && window.removeEventListener('resize', onResize)\n    updateLocation.value = undefined\n    scope?.stop()\n  })\n\n  function onResize (e: Event) {\n    updateLocation.value?.(e)\n  }\n\n  return {\n    contentStyles,\n    updateLocation,\n  }\n}\n\nfunction staticLocationStrategy () {\n  // TODO\n}\n\n/** Get size of element ignoring max-width/max-height */\nfunction getIntrinsicSize (el: HTMLElement) {\n  // const scrollables = new Map<Element, [number, number]>()\n  // el.querySelectorAll('*').forEach(el => {\n  //   const x = el.scrollLeft\n  //   const y = el.scrollTop\n  //   if (x || y) {\n  //     scrollables.set(el, [x, y])\n  //   }\n  // })\n\n  // const initialMaxWidth = el.style.maxWidth\n  // const initialMaxHeight = el.style.maxHeight\n  // el.style.removeProperty('max-width')\n  // el.style.removeProperty('max-height')\n\n  /* eslint-disable-next-line sonarjs/prefer-immediate-return */\n  const contentBox = nullifyTransforms(el)\n\n  contentBox.x -= parseFloat(el.style.left || 0)\n  contentBox.y -= parseFloat(el.style.top || 0)\n\n  // el.style.maxWidth = initialMaxWidth\n  // el.style.maxHeight = initialMaxHeight\n  // scrollables.forEach((position, el) => {\n  //   el.scrollTo(...position)\n  // })\n\n  return contentBox\n}\n\nfunction connectedLocationStrategy (data: LocationStrategyData, props: StrategyProps, contentStyles: Ref<Record<string, string>>) {\n  const activatorFixed = isFixedPosition(data.activatorEl.value)\n  if (activatorFixed) {\n    Object.assign(contentStyles.value, {\n      position: 'fixed',\n    })\n  }\n\n  const { preferredAnchor, preferredOrigin } = destructComputed(() => {\n    const parsedAnchor = parseAnchor(props.location, data.isRtl.value)\n    const parsedOrigin =\n      props.origin === 'overlap' ? parsedAnchor\n      : props.origin === 'auto' ? flipSide(parsedAnchor)\n      : parseAnchor(props.origin, data.isRtl.value)\n\n    // Some combinations of props may produce an invalid origin\n    if (parsedAnchor.side === parsedOrigin.side && parsedAnchor.align === flipAlign(parsedOrigin).align) {\n      return {\n        preferredAnchor: flipCorner(parsedAnchor),\n        preferredOrigin: flipCorner(parsedOrigin),\n      }\n    } else {\n      return {\n        preferredAnchor: parsedAnchor,\n        preferredOrigin: parsedOrigin,\n      }\n    }\n  })\n\n  const [minWidth, minHeight, maxWidth, maxHeight] =\n    (['minWidth', 'minHeight', 'maxWidth', 'maxHeight'] as const).map(key => {\n      return computed(() => {\n        const val = parseFloat(props[key]!)\n        return isNaN(val) ? Infinity : val\n      })\n    })\n\n  const offset = computed(() => {\n    if (Array.isArray(props.offset)) {\n      return props.offset\n    }\n    if (typeof props.offset === 'string') {\n      const offset = props.offset.split(' ').map(parseFloat)\n      if (offset.length < 2) offset.push(0)\n      return offset\n    }\n    return typeof props.offset === 'number' ? [props.offset, 0] : [0, 0]\n  })\n\n  let observe = false\n  if (IN_BROWSER) {\n    const observer = new ResizeObserver(() => {\n      if (observe) updateLocation()\n    })\n\n    watch([data.activatorEl, data.contentEl], ([newActivatorEl, newContentEl], [oldActivatorEl, oldContentEl]) => {\n      if (oldActivatorEl) observer.unobserve(oldActivatorEl)\n      if (newActivatorEl) observer.observe(newActivatorEl)\n\n      if (oldContentEl) observer.unobserve(oldContentEl)\n      if (newContentEl) observer.observe(newContentEl)\n    }, {\n      immediate: true,\n    })\n\n    onScopeDispose(() => {\n      observer.disconnect()\n    })\n  }\n\n  // eslint-disable-next-line max-statements\n  function updateLocation () {\n    observe = false\n    requestAnimationFrame(() => {\n      requestAnimationFrame(() => observe = true)\n    })\n\n    if (!data.activatorEl.value || !data.contentEl.value) return\n\n    const targetBox = data.activatorEl.value.getBoundingClientRect()\n    const contentBox = getIntrinsicSize(data.contentEl.value)\n    const scrollParents = getScrollParents(data.contentEl.value)\n    const viewportMargin = 12\n\n    if (!scrollParents.length) {\n      scrollParents.push(document.documentElement)\n      if (!(data.contentEl.value.style.top && data.contentEl.value.style.left)) {\n        contentBox.x += parseFloat(document.documentElement.style.getPropertyValue('--v-body-scroll-x') || 0)\n        contentBox.y += parseFloat(document.documentElement.style.getPropertyValue('--v-body-scroll-y') || 0)\n      }\n    }\n\n    const viewport = scrollParents.reduce<Box>((box: Box | undefined, el) => {\n      const rect = el.getBoundingClientRect()\n      const scrollBox = new Box({\n        x: el === document.documentElement ? 0 : rect.x,\n        y: el === document.documentElement ? 0 : rect.y,\n        width: el.clientWidth,\n        height: el.clientHeight,\n      })\n\n      if (box) {\n        return new Box({\n          x: Math.max(box.left, scrollBox.left),\n          y: Math.max(box.top, scrollBox.top),\n          width: Math.min(box.right, scrollBox.right) - Math.max(box.left, scrollBox.left),\n          height: Math.min(box.bottom, scrollBox.bottom) - Math.max(box.top, scrollBox.top),\n        })\n      }\n      return scrollBox\n    }, undefined!)\n    viewport.x += viewportMargin\n    viewport.y += viewportMargin\n    viewport.width -= viewportMargin * 2\n    viewport.height -= viewportMargin * 2\n\n    let placement = {\n      anchor: preferredAnchor.value,\n      origin: preferredOrigin.value,\n    }\n\n    function checkOverflow (_placement: typeof placement) {\n      const box = new Box(contentBox)\n      const targetPoint = anchorToPoint(_placement.anchor, targetBox)\n      const contentPoint = anchorToPoint(_placement.origin, box)\n\n      let { x, y } = getOffset(targetPoint, contentPoint)\n\n      switch (_placement.anchor.side) {\n        case 'top': y -= offset.value[0]; break\n        case 'bottom': y += offset.value[0]; break\n        case 'left': x -= offset.value[0]; break\n        case 'right': x += offset.value[0]; break\n      }\n\n      switch (_placement.anchor.align) {\n        case 'top': y -= offset.value[1]; break\n        case 'bottom': y += offset.value[1]; break\n        case 'left': x -= offset.value[1]; break\n        case 'right': x += offset.value[1]; break\n      }\n\n      box.x += x\n      box.y += y\n\n      box.width = Math.min(box.width, maxWidth.value)\n      box.height = Math.min(box.height, maxHeight.value)\n\n      const overflows = getOverflow(box, viewport)\n\n      return { overflows, x, y }\n    }\n\n    let x = 0; let y = 0\n    const available = { x: 0, y: 0 }\n    const flipped = { x: false, y: false }\n    let resets = -1\n    while (true) {\n      if (resets++ > 10) {\n        consoleError('Infinite loop detected in connectedLocationStrategy')\n        break\n      }\n\n      const { x: _x, y: _y, overflows } = checkOverflow(placement)\n\n      x += _x\n      y += _y\n\n      contentBox.x += _x\n      contentBox.y += _y\n\n      // flip\n      {\n        const axis = getAxis(placement.anchor)\n        const hasOverflowX = overflows.x.before || overflows.x.after\n        const hasOverflowY = overflows.y.before || overflows.y.after\n\n        let reset = false\n        ;['x', 'y'].forEach(key => {\n          if (\n            (key === 'x' && hasOverflowX && !flipped.x) ||\n            (key === 'y' && hasOverflowY && !flipped.y)\n          ) {\n            const newPlacement = { anchor: { ...placement.anchor }, origin: { ...placement.origin } }\n            const flip = key === 'x'\n              ? axis === 'y' ? flipAlign : flipSide\n              : axis === 'y' ? flipSide : flipAlign\n            newPlacement.anchor = flip(newPlacement.anchor)\n            newPlacement.origin = flip(newPlacement.origin)\n            const { overflows: newOverflows } = checkOverflow(newPlacement)\n            if (\n              (newOverflows[key].before <= overflows[key].before &&\n                newOverflows[key].after <= overflows[key].after) ||\n              (newOverflows[key].before + newOverflows[key].after <\n                (overflows[key].before + overflows[key].after) / 2)\n            ) {\n              placement = newPlacement\n              reset = flipped[key] = true\n            }\n          }\n        })\n        if (reset) continue\n      }\n\n      // shift\n      if (overflows.x.before) {\n        x += overflows.x.before\n        contentBox.x += overflows.x.before\n      }\n      if (overflows.x.after) {\n        x -= overflows.x.after\n        contentBox.x -= overflows.x.after\n      }\n      if (overflows.y.before) {\n        y += overflows.y.before\n        contentBox.y += overflows.y.before\n      }\n      if (overflows.y.after) {\n        y -= overflows.y.after\n        contentBox.y -= overflows.y.after\n      }\n\n      // size\n      {\n        const overflows = getOverflow(contentBox, viewport)\n        available.x = viewport.width - overflows.x.before - overflows.x.after\n        available.y = viewport.height - overflows.y.before - overflows.y.after\n\n        x += overflows.x.before\n        contentBox.x += overflows.x.before\n        y += overflows.y.before\n        contentBox.y += overflows.y.before\n      }\n\n      break\n    }\n\n    const axis = getAxis(placement.anchor)\n\n    Object.assign(contentStyles.value, {\n      '--v-overlay-anchor-origin': `${placement.anchor.side} ${placement.anchor.align}`,\n      transformOrigin: `${placement.origin.side} ${placement.origin.align}`,\n      // transform: `translate(${pixelRound(x)}px, ${pixelRound(y)}px)`,\n      top: convertToUnit(pixelRound(y)),\n      left: convertToUnit(pixelRound(x)),\n      minWidth: convertToUnit(axis === 'y' ? Math.min(minWidth.value, targetBox.width) : minWidth.value),\n      maxWidth: convertToUnit(pixelCeil(clamp(available.x, minWidth.value === Infinity ? 0 : minWidth.value, maxWidth.value))),\n      maxHeight: convertToUnit(pixelCeil(clamp(available.y, minHeight.value === Infinity ? 0 : minHeight.value, maxHeight.value))),\n    })\n  }\n\n  watch(\n    () => [\n      preferredAnchor.value,\n      preferredOrigin.value,\n      props.offset,\n      props.minWidth,\n      props.minHeight,\n      props.maxWidth,\n      props.maxHeight,\n    ],\n    () => updateLocation(),\n    { immediate: !activatorFixed }\n  )\n\n  if (activatorFixed) nextTick(() => updateLocation())\n  requestAnimationFrame(() => {\n    if (contentStyles.value.maxHeight) updateLocation()\n  })\n\n  return { updateLocation }\n}\n\nfunction pixelRound (val: number) {\n  return Math.round(val * devicePixelRatio) / devicePixelRatio\n}\n\nfunction pixelCeil (val: number) {\n  return Math.ceil(val * devicePixelRatio) / devicePixelRatio\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}